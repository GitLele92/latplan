#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros dynamic-space-size=8000 -Q -L sbcl -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp (ql:quickload '(cl-csv iterate alexandria trivia.ppcre function-cache) :silent t)
  )

(defpackage :ros.script.to-sas.3690427216
  (:use :cl :cl-csv :iterate :alexandria :trivia.ppcre :function-cache))
(in-package :ros.script.to-sas.3690427216)

(defun read-as-lists (csv)
  (with-open-file (s csv)
    (cl-csv:read-csv s
                     :separator #\Space
                     :map-fn (lambda (args)
                               (mapcar #'read-from-string args)))))

(function-cache:defcached sym (&rest args)
  (intern (format nil "~{~a~}" args))
  ;; (apply #'symbolicate (mapcar #'princ-to-string args))
  )

(defun make-domain (data)
  (let* ((dims (iota (/ (length (first data)) 2)))
         (coordinate      (mapcar (curry #'sym '?z)      dims))
         (coordinate-from (mapcar (curry #'sym '?from-z) dims))
         (coordinate-to   (mapcar (curry #'sym '?to-z)   dims)))
    `(define (domain latent)
         (:requirements :strips)
       (:predicates
        (at   ,@coordinate)  ; current position
        (connected ,@coordinate-from  ; known origin
                   ,@coordinate-to))  ; known destination
       (:action move
                :parameters ,(append coordinate-from coordinate-to)
                :precondition
                (and (at   ,@coordinate-from)
                     (connected ,@coordinate-from ,@coordinate-to))
                :effect
                (and (not (at ,@coordinate-from))
                     (at ,@coordinate-to))))))

(defun coordinate->objects (coordinate)
  (mapcar (lambda (value) (sym 'v value))
          coordinate))

(defun make-problem (data init goal)
  (let* ((dimension (/ (length (first data)) 2))
         (transitions (remove-duplicates
                       (iter (for transition-def in data)
                             (for from = (coordinate->objects
                                          (subseq transition-def 0 dimension)))
                             (for to   = (coordinate->objects
                                          (subseq transition-def dimension)))
                             (collect (cons from to)))
                       :test #'equalp))
         (initial-state-objects (coordinate->objects init))
         (goal-state-objects (coordinate->objects goal)))
    `(define (problem ,(symbolicate
                        (format nil "PROBLEM-~{~a~^-~}"
                                (reverse (subseq (multiple-value-list (get-decoded-time)) 0 6)))))
         (:domain latent)
       (:objects ,@(remove-duplicates (flatten transitions)))
       (:init ,@(iter (for (from . to) in transitions)
                      (collect `(connected ,@from ,@to)))
              (at ,@initial-state-objects))
       (:goal (at ,@goal-state-objects)))))

(defun main (csv &rest coordinates)
  (let ((l (length coordinates)))
    (let ((init (mapcar #'read-from-string (subseq coordinates 0 (/ l 2))))
          (goal (mapcar #'read-from-string (subseq coordinates (/ l 2)))))
      (let ((data (read-as-lists csv)))
        (with-output-to-file (s "domain.pddl" :if-does-not-exist :create :if-exists :supersede)
          (print (make-domain data) s))
        (with-output-to-file (s "problem.pddl" :if-does-not-exist :create :if-exists :supersede)
          (print (make-problem data init goal) s))))))

;;; vim: set ft=lisp lisp:



