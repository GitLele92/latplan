#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros dynamic-space-size=8000 -Q -L sbcl -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp (ql:quickload '(iterate alexandria trivia.ppcre immutable-struct swank) :silent t)
  )

(defpackage :msdd
  (:use :cl :iterate :alexandria :trivia :trivia.ppcre)
  (:shadowing-import-from :immutable-struct :ftype :defstruct))
(in-package :msdd)
(SETF *ARITY-CHECK-BY-TEST-CALL* NIL)
;;; set up the learning data

(defun read-as-bvs (csv)
  (iter (for line in-file csv using #'read-line)
        (for bv = (iter (for o in-stream (make-string-input-stream line))
                        (collect o result-type bit-vector)))
        (when (plusp (length bv))
          (collect bv))))

(defun bvs-array (bvs)
  (let ((batch (length bvs))
        (w (/ (length (first bvs)) 2)))
    (let* ((a (make-array (list batch 2 w) :element-type 'bit))
           (arm (make-array (* batch 2 w)  :element-type 'bit :displaced-to a)))
      (iter (for b below batch)
            (for bv in bvs)
            (replace arm bv :start1 (* b 2 w) :end1 (* (1+ b) 2 w)))
      a)))

;; search data structure

(defun multitoken (width)
  (make-array width :element-type '(integer 0 2) :initial-element 2))

(defun copy-multitoken (mt1)
  (let ((mt2 (multitoken (length mt1))))
    (replace mt2 mt1)
    mt2))

(defun required ()
  (error "missing required argument"))

(deftype stream-value ()
  `(integer 0 2))

(defstruct node
  ;; (precursor (required) :type (simple-array stream-value))
  ;; (successor (required) :type (simple-array stream-value))
  (data (required) :type (simple-array stream-value)))

(declaim (inline node-precursor))
(ftype node-precursor node (array stream-value))
(defun node-precursor (node)
  (ematch node
    ((node data)
     (make-array (/ (length data) 2) :element-type 'stream-value :displaced-to data))))


(declaim (inline node-successor))
(ftype node-successor node (array stream-value))
(defun node-successor (node)
  (match node
    ((node data)
     (let ((width (/ (length data) 2)))
       (make-array width
                   :element-type 'stream-value :displaced-to data
                   :displaced-index-offset width)))))

;; MSDD algorithm

(defun expand (node)
  (match node
    ((node data)
     (flet ((specify (multitoken index what)
              (let ((mt2 (copy-multitoken multitoken)))
                (setf (aref mt2 index) what)
                mt2)))
       ;; specify 1 bit of the precursor or the successor.
       ;; Since the precursor and the successor are the displaced arrays to
       ;; a single underlying data array,
       ;; we can iterate over the underlying array.
       (let ((rightmost (or (position 2 data :from-end t :test #'/=) -1)))
         (iter (for i from (1+ rightmost) below (length data))
               (collect (node (specify data i 0)))
               (collect (node (specify data i 1)))))))))

;; node evaluation functions

(defun wickens-cooccurence-g (n1 n2 n3 n4)
  "Wickens, T. D. 1989. Multiway Contingency Tables Analysis for the Social Sciences. Lawrence Erlbaum Associates."
  (let* ((1/all (/ (+ n1 n2 n3 n4)))
         (r1 (+ n1 n2))
         (c1 (+ n1 n3))
         (r2 (+ n3 n4))
         (c2 (+ n2 n4))
         (n1^ (* r1 c1 1/all))
         (n2^ (* r1 c2 1/all))
         (n3^ (* r2 c1 1/all))
         (n4^ (* r2 c2 1/all)))
    (* 2
       (+ (* n1 (log (/ n1 n1^)))
          (* n2 (log (/ n2 n2^)))
          (* n3 (log (/ n3 n3^)))
          (* n4 (log (/ n4 n4^)))))))

(defun msdd-gmax1 (n1 n2 n3 n4)
  (max (wickens-cooccurence-g n1 n2 1e-6 (+ n3 n4))
       (wickens-cooccurence-g 1e-6 (+ n1 n2) n3 n4)))

(defun msdd-gmax2 (n1 n2 n3 n4)
  (max (let ((tmp1 (+ n2 n3 n4)))
         (if (<= n1 tmp1)
             ;; using 1e-6 instead of 0 to prevent division-by-zero
             (wickens-cooccurence-g n1 1e-6 1e-6 tmp1)
             (let ((all/2 (/ (+ n1 tmp1) 2)))
               (wickens-cooccurence-g all/2 1e-6 1e-6 all/2))))
       (cond
         ((>= n1 (abs (- n2 n3)))
          (let ((tmp2 (+ n1 n2 n3)))
            (wickens-cooccurence-g 1e-6 tmp2 tmp2 n4)))
         ((> n2 n3)
          (wickens-cooccurence-g 1e-6 n2 (+ n1 n3) n4))
         (t
          (wickens-cooccurence-g 1e-6 (+ n1 n2) n3 n4)))))

(ftype contingency-table node (simple-array bit (* 2 *))
       (values single-float
               single-float
               single-float
               single-float))
(defun contingency-table (node array)
  (ematch* (array node)
    (((array :dimensions (list batch 2 width))
      (node precursor successor))
     (let ((n1 1e-6) (n2 1e-6) (n3 1e-6) (n4 1e-6))
       (iter (for b below batch)
             (for x = (iter (for i below width)
                            (always
                             (let ((v1 (aref precursor i))
                                   (v2 (aref array b 0 i)))
                               (or (= v1 2)        ;don't-care
                                   (= v1 v2))))))
             (for y = (iter (for i below width)
                            (always
                             (let ((v1 (aref successor i))
                                   (v2 (aref array b 1 i)))
                               (or (= v1 2)        ;don't-care
                                   (= v1 v2))))))
             (match* (x y)
               ((t t)     (incf n1))
               ((t nil)   (incf n2))
               ((nil t)   (incf n3))
               ((nil nil) (incf n4))))
       (values n1 n2 n3 n4)))))

(defun fmax (node array)
  (match node
    ((node successor)
     (multiple-value-call
         (if (find 2 successor :test #'/=)
             ;; non-empty successor
             #'msdd-gmax1
             ;; empty successor
             #'msdd-gmax2)
       (contingency-table node array)))))

(defun progress (width)
  (let ((count 0))
    (lambda (&optional (char #\.))
      (princ char)
      (incf count)
      (when (< width count)
        (progn (setf count 0)
               (terpri))))))

(defun bistate-msdd (array g-threashold)
  "A modification of Oates, Cohen, ICML16 on binary variables with lag fixed to 1.
Also, instead of working on the sequence of states, it works on individual pairs of states."
  (match array
    ((array :dimensions (list _ 2 width))
     (let ((acc nil)
           (open (list (node (multitoken (* 2 width)))))
           (max-open 0)
           (progress (progress 60)))
       (pprint-logical-block (*standard-output* nil)
         (pprint-newline :mandatory)
         (iter (while open)
               (for top = (pop open))
               (when (> g-threashold (fmax top array))
                 (next-iteration))
               (funcall progress)
               (iter (for child in (expand top))
                     (for g = (multiple-value-call
                                  #'wickens-cooccurence-g
                                (contingency-table child array)))
                     (push child open)
                     (when (>= g g-threashold)
                       (push (cons g child) acc)))
               (maxf max-open (length open))))
       (print `(:max-open ,max-open))
       acc))))


(defun main (csv)
  (let ((*print-right-margin* 70))
    (swank:profile-reset)
    (swank:profile-package :msdd t nil)
    (time (bistate-msdd (bvs-array (read-as-bvs csv)) 500))
    (swank:profile-report)
    ;; (format t "~(~:S~)~%"
    ;;         (make-domain (read-as-lists csv)))
    ))


;;; vim: set ft=lisp lisp:



