#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros dynamic-space-size=8000 -Q -L sbcl -- $0 "$@"
|#
(progn ;;init forms
  #+quicklisp (ql:quickload '(iterate alexandria trivia.ppcre immutable-struct swank
                              priority-queue simpsamp lparallel) :silent t)
  )

(defpackage :msdd
  (:use :cl :iterate :alexandria :trivia :trivia.ppcre :priority-queue :lparallel)
  (:shadowing-import-from :immutable-struct :ftype :defstruct))
(in-package :msdd)
(SETF *ARITY-CHECK-BY-TEST-CALL* NIL)
(defvar *num-processes*
    (read-from-string
     (uiop:run-program "cat /proc/cpuinfo | grep -c processor" :output :string)))
;; (setf *kernel* (make-kernel *num-processes*))

;;; set up the learning data

(defun read-as-bvs (csv)
  (iter (for line in-file csv using #'read-line)
        (for bv = (iter (for o in-stream (make-string-input-stream line))
                        (collect o result-type bit-vector)))
        (when (plusp (length bv))
          (collect bv))))

(defun bvs-array (bvs)
  "Stores the bit vectors into a single large bit vector, then
 returns an array displaced to the underlying bitvector"
  (let ((batch (length bvs))
        (w (/ (length (first bvs)) 2)))
    (let* ((arm (make-array (* batch 2 w)  :element-type 'bit))
           (a (make-array (list batch 2 w) :element-type 'bit :displaced-to arm)))
      (iter (for b below batch)
            (for bv in bvs)
            (replace arm bv :start1 (* b 2 w) :end1 (* (1+ b) 2 w)))
      a)))

;;; print the pddl domain

(defclass _nil () ())
(defun _nil () (make-instance '_nil))
(defmethod print-object ((object _nil) stream)
  (write-string "()" stream))

(defun sym (&rest args)
  (intern (format nil "~{~a~}" args)))

(defun z (dim)
  "(z 0) returns a form (Z0) and alike"
  (list (sym 'z dim)))

(defun make-domain (data)
  (let* ((dim (/ (length (first data)) 2))
         (dims (iota dim)))
    `(define (domain latent)
         (:requirements :strips :negative-preconditions)
       (:predicates
        ,@(mapcar #'z dims))
       ,@(iter (for transition in data)
               (for from = (subseq transition 0 dim))
               (for to   = (subseq transition dim))
               (for i from 0)
               (collect
                   `(:action ,(sym 'a (apply #'concatenate 'string
                                             (map 'list #'princ-to-string transition)))
                     :parameters ,(_nil) ;TODO: Is it possible to use parameters in our framework?
                     :precondition
                     (and ,@(iter (for d in dims)
                                  (for value in-vector from)
                                  (match value
                                    (2 nil)
                                    (1 (collect (z d)))
                                    (0 (collect `(not ,(z d)))))))
                     :effect
                     (and ,@(iter (for d in dims)
                                  (for value1 in-vector from)
                                  (for value2 in-vector to)
                                  (ematch* (value1 value2)
                                    ((_ 2) nil)
                                    ((2 1) (collect (z d)))
                                    ((2 0) (collect `(not ,(z d))))
                                    ((0 0) nil)
                                    ((1 1) nil)
                                    ((0 1) (collect (z d)))
                                    ((1 0) (collect `(not ,(z d)))))))))))))

;;; search data structure

(deftype sf () 'single-float)
(deftype fn () 'fixnum)
(deftype half () `(unsigned-byte ,(1- (/ (floor (log most-positive-fixnum 2)) 2))))

(defun multitoken (width)
  (make-array width :initial-element 1 :element-type 'bit :adjustable nil :fill-pointer nil))

(defun copy-multitoken (mt1)
  (let ((mt2 (multitoken (length mt1))))
    (replace mt2 mt1)
    mt2))

(defun required ()
  (error "missing required argument"))

(defstruct node
  ;; (precursor (required) :type (simple-array bit))
  ;; (successor (required) :type (simple-array bit))
  (data (required) :type simple-bit-vector)
  (mask (required) :type simple-bit-vector))

(declaim (inline node-precursor))
(ftype node-precursor node bit-vector)
(defun node-precursor (node)
  (ematch node
    ((node data)
     (make-array (/ (length data) 2)
                 :element-type 'bit
                 :displaced-to data))))

(declaim (inline node-precursor-*))
(ftype node-precursor-* node bit-vector)
(defun node-precursor-* (node)
  (ematch node
    ((node data)
     (make-array (/ (length data) 2)
                 :element-type 'bit
                 :displaced-to data))))


(declaim (inline node-successor))
(ftype node-successor node bit-vector)
(defun node-successor (node)
  (match node
    ((node data)
     (let ((width (/ (length data) 2)))
       (make-array width
                   :element-type 'bit
                   :displaced-to data
                   :displaced-index-offset width)))))


(declaim (inline node-successor-*))
(ftype node-successor-* node bit-vector)
(defun node-successor-* (node)
  (match node
    ((node data)
     (let ((width (/ (length data) 2)))
       (make-array width
                   :element-type 'bit
                   :displaced-to data
                   :displaced-index-offset width)))))

(defun as-012 (node)
  (ematch node
    ((node data mask)
     (map 'vector (lambda-match*
                    ((_ 1) 2)
                    ((d 0) d)) data mask))))


;;; node evaluation functions

(declaim (inline wickens-cooccurence-g))
(ftype wickens-cooccurence-g real real real real sf)
(defun wickens-cooccurence-g (n1 n2 n3 n4)
  "
Following the definition in Oates,Cohen,ICML96. See also:
Wickens, T. D. 1989. Multiway Contingency Tables Analysis for the Social Sciences. Lawrence Erlbaum Associates.
"
  (let* ((n1 (float n1))
         (n2 (float n2))
         (n3 (float n3))
         (n4 (float n4))
         (1/all (/ (+ n1 n2 n3 n4)))
         (r1 (+ n1 n2))
         (c1 (+ n1 n3))
         (r2 (+ n3 n4))
         (c2 (+ n2 n4))
         (n1^ (* r1 c1 1/all))
         (n2^ (* r1 c2 1/all))
         (n3^ (* r2 c1 1/all))
         (n4^ (* r2 c2 1/all)))
    (* 2
       ;; adding 1e-6 to prevent division-by-zero
       (+ (* n1 (log (/ (+ 1e-6 n1) (+ 1e-6 n1^))))
          (* n2 (log (/ (+ 1e-6 n2) (+ 1e-6 n2^))))
          (* n3 (log (/ (+ 1e-6 n3) (+ 1e-6 n3^))))
          (* n4 (log (/ (+ 1e-6 n4) (+ 1e-6 n4^))))))))

(declaim (inline cross-entropy))
(ftype cross-entropy real real real real sf)
(defun cross-entropy (n1 n2 n3 n4)
  "Using this instead of wickens-cooccurence-g because
 this value is normalized against the total sample size."
  (let* ((n1 (float n1))
         (n2 (float n2))
         (n3 (float n3))
         (n4 (float n4))
         (1/all (/ (+ n1 n2 n3 n4)))
         (r1 (+ n1 n2))
         (c1 (+ n1 n3))
         (r2 (+ n3 n4))
         (c2 (+ n2 n4))
         (n1^ (* r1 c1 1/all))
         (n2^ (* r1 c2 1/all))
         (n3^ (* r2 c1 1/all))
         (n4^ (* r2 c2 1/all)))
    (* 1/all
       ;; adding 1e-6 to prevent division-by-zero
       (+ (* n1 (log (/ (+ 1e-6 n1) (+ 1e-6 n1^))))
          (* n2 (log (/ (+ 1e-6 n2) (+ 1e-6 n2^))))
          (* n3 (log (/ (+ 1e-6 n3) (+ 1e-6 n3^))))
          (* n4 (log (/ (+ 1e-6 n4) (+ 1e-6 n4^))))))))

(ftype msdd-gmax1 fn fn fn fn sf)
(defun msdd-gmax1 (n1 n2 n3 n4)
  (max (cross-entropy n1 n2 0 (+ n3 n4))
       (cross-entropy 0 (+ n1 n2) n3 n4)))

(ftype msdd-gmax2 fn fn fn fn sf)
(defun msdd-gmax2 (n1 n2 n3 n4)
  (max (let ((tmp1 (+ n2 n3 n4)))
         (if (<= n1 tmp1)
             (cross-entropy n1 0 0 tmp1)
             (let ((all/2 (/ (+ n1 tmp1) 2)))
               (cross-entropy all/2 0 0 all/2))))
       (cond
         ((>= n1 (abs (- n2 n3)))
          (let ((tmp2 (+ n1 n2 n3)))
            (cross-entropy 0 tmp2 tmp2 n4)))
         ((> n2 n3)
          (cross-entropy 0 n2 (+ n1 n3) n4))
         (t
          (cross-entropy 0 (+ n1 n2) n3 n4)))))

(ftype msdd-gmax3 node fn fn fn fn sf)
(defun msdd-gmax3 (node n1 n2 n3 n4)
  (match node
    ((node mask)
     (if (not (zerop (count 0 mask :start (/ (length mask) 2))))
         ;; non-empty successor
         (msdd-gmax1 n1 n2 n3 n4)
         ;; empty successor
         (msdd-gmax2 n1 n2 n3 n4)))))



(defmacro dotimes-inline ((var count &optional result-form) &body body &environment env)
  (check-type var symbol)
  (let ((count (macroexpand count env)))
    (assert (and (constantp count) (numberp count)))
    (iter (for c to count)
          (when (first-iteration-p)
            (collect 'progn))
          (collect
              (if (< c count)
                  `(symbol-macrolet ((,var ,c))
                     ,@body)
                  result-form)))))

(defmacro dotimes-unroll4 ((base offset
                            count unroll
                            &optional result)
                           &body body
                           &environment env)
  (with-gensyms (quat mod nth-loop)
    (let ((unroll (macroexpand unroll env))
          (delta (gensym "D")))
      `(let ((,base 0))
         (declare (fixnum ,base))
         (multiple-value-bind (,quat ,mod) (floor ,count ,unroll)
           (declare (fixnum ,quat)
                    ((mod ,unroll) ,mod))
           (symbol-macrolet ((,delta ,unroll))
             (dotimes (,nth-loop ,quat)
               (declare (ignorable ,nth-loop))
               (dotimes-inline (,offset ,unroll)
                 ,@body)
               (incf ,base ,delta)))
           (symbol-macrolet ((,delta 1)
                             (,offset 0))
             (dotimes (,nth-loop ,mod)
               ,@body
               (incf ,base ,delta)))
           ,result)))))

(ftype contingency-table node (array bit (* 2 *)) (values fn fn fn fn))
#+nil
(let ((matching  (make-array 0 :element-type 'bit))
      (prec-mask (make-array 0 :element-type 'bit))
      (succ-mask (make-array 0 :element-type 'bit))
      (all-true  (make-array 0 :element-type 'bit))
      (tmp1    (make-array 0 :element-type 'bit)))
  (declare (simple-bit-vector matching prec-mask succ-mask all-true))
  (defun contingency-table (node array)
    (declare (optimize (speed 3) (safety 0)))
    (ematch* (array node)
      (((array :dimensions (list batch 2 width)
               :displaced-to back-array)
        (node data mask))
       (declare (simple-bit-vector back-array)
                (half width batch))
       (let* ((n1 0) (n2 0) (n3 0) (n4 0)
              (width2 (* 2 width)))
         (declare (fixnum n1 n2 n3 n4)
                  (half width2))
         (when (/= width2 (length matching))
           (setf matching  (make-array width2 :element-type 'bit)
                 prec-mask (make-array width2 :element-type 'bit)
                 succ-mask (make-array width2 :element-type 'bit)
                 all-true  (make-array width2 :element-type 'bit)
                 tmp1      (make-array width2 :element-type 'bit))
           (fill prec-mask 1 :start 0 :end width)
           (fill succ-mask 1 :start width)
           (fill all-true  1))
         (dotimes-unroll4 (b offset batch 2)
           (let ((start (the fixnum (* (the fixnum (+ b offset)) width2))))
             (replace tmp1 back-array :start2 start :end2 (the fixnum (+ start width2))))
         ;; (dotimes (b batch)
         ;;   (let ((start (* b width2)))
         ;;     (replace tmp1 back-array :start2 start :end2 (+ start width2)))
           (bit-eqv data tmp1 matching)
           (bit-ior matching mask matching)
           (ematch* ((equal all-true (bit-ior matching succ-mask tmp1))
                     (equal all-true (bit-ior matching prec-mask tmp1)))
             ((t t)     (incf n1))
             ((t nil)   (incf n2))
             ((nil t)   (incf n3))
             ((nil nil) (incf n4))))
         (values n1 n2 n3 n4))))))

(defun contingency-table (node array)
  (declare (optimize (speed 3) (safety 0)))
  (ematch* (array node)
    (((array :dimensions (list batch 2 width)
             :displaced-to back-array)
      (node data mask))
     (declare (simple-bit-vector back-array)
              (half width batch))
     (let* ((n1 0) (n2 0) (n3 0) (n4 0)
            (width2 (* 2 width))
            (matching  (make-array width2 :element-type 'bit))
            (prec-mask (make-array width2 :element-type 'bit))
            (succ-mask (make-array width2 :element-type 'bit))
            (all-true  (make-array width2 :element-type 'bit))
            (tmp1      (make-array width2 :element-type 'bit)))
       (declare (simple-bit-vector matching prec-mask succ-mask all-true)
                (fixnum n1 n2 n3 n4)
                (half width2))
       (fill prec-mask 1 :start 0 :end width)
       (fill succ-mask 1 :start width)
       (fill all-true  1)
       (dotimes-unroll4 (b offset batch 2)
         (let ((start (the fixnum (* (the fixnum (+ b offset)) width2))))
           (replace tmp1 back-array :start2 start :end2 (the fixnum (+ start width2))))
         (bit-eqv data tmp1 matching)
         (bit-ior matching mask matching)
         (ematch* ((equal all-true (bit-ior matching succ-mask tmp1))
                   (equal all-true (bit-ior matching prec-mask tmp1)))
           ((t t)     (incf n1))
           ((t nil)   (incf n2))
           ((nil t)   (incf n3))
           ((nil nil) (incf n4))))
       (values n1 n2 n3 n4)))))

;;; Pruning rule for action schema

(defun valid-node (node)
  (match node
    ((node precursor successor
           precursor-* successor-*)
     ;; 1. same bit should not specify the same value (p4,left,par3)
     (let ((tmp1 (bit-eqv precursor successor))  ; common bits
           (tmp2 (bit-xor precursor precursor))) ; as zero
       (bit-andc2 tmp1 precursor-* tmp1) ; 1 = wild. filter non-wild
       (bit-andc2 tmp1 successor-* tmp1)
       (equal tmp2 tmp1)               ; all zero
       ;; 2. actions should encode changes? I don't think this is necessary...
       ))))

(defun valid-leaf-node (node)
  (match node
    ((node successor-*)
     ;; 3. there should be some effects (p4,right,line3-4)
     (not (equal (bit-eqv successor-* successor-*) ; as one
                 successor-*)))))

;;; MSDD algorithm

(ftype expand node list)
(defun expand (node)
  (match node
    ((node data mask)
     (flet ((specify (multitoken index what)
              (let ((mt2 (copy-multitoken multitoken)))
                (setf (aref mt2 index) what)
                mt2)))
       ;; specify 1 bit of the precursor or the successor.
       ;; Since the precursor and the successor are the displaced arrays to
       ;; a single underlying data array,
       ;; we can iterate over the underlying array.
       (let ((rightmost (or (position 0 mask :from-end t) -1)))
         (iter (for i from (1+ rightmost) below (length data))
               (collect (node (specify data i 0) (specify mask i 0)))
               (collect (node (specify data i 1) (specify mask i 0)))))))))

(defun progress (width)
  (let ((count 0))
    (lambda (&optional (char #\.) &rest args)
      (princ char)
      (incf count)
      (when (< width count)
        (progn (setf count 0)
               (format t " ~{~a~^ ~}~%" args)))
      (finish-output))))

(defmacro print-variables (&rest args)
  `(print (list ,@(iter (for arg in args)
                        (collect `(quote ,arg))
                        (collect arg)))
          *error-output*))

;; it seems there are still some magic happening here... 

(defun bistate-msdd (array g-threashold max-schema)
  "A modification of Oates, Cohen, ICML16 on binary variables with lag fixed to 1.
Also, instead of working on the sequence of states, it works on individual pairs of states."
  (match array
    ((array :dimensions (list batch 2 width))
     (format *error-output* "number of samples: ~a~%encoding length: ~a~%" batch width)
     (let ((open (make-pqueue #'> :key-type 'sf :value-type 'node))
           (acc (make-pqueue #'< :key-type 'sf :value-type 'node))
           (lopen (bt:make-lock "open"))
           (lacc (bt:make-lock "acc"))
           threads)
       (labels ((task (node)
                  (block nil
                    ;; prune the child following Oates,Cohen,AAAI98
                    (unless (valid-node node) (return))
                    (multiple-value-bind (n1 n2 n3 n4)
                        (contingency-table node array)
                      (let ((g (cross-entropy n1 n2 n3 n4)))
                        (when (and (< g-threashold g)
                                   (valid-leaf-node node))
                          (bt:with-lock-held (lacc)
                            (when (or (< (pqueue-length acc) max-schema)
                                      (< (pqueue-front-key acc) g))
                              (pqueue-push node g acc))
                            (when (< max-schema (pqueue-length acc))
                              (pqueue-pop acc)))))
                      (let ((f (msdd-gmax3 node n1 n2 n3 n4)))
                        (when (and (< g-threashold f)
                                   (bt:with-lock-held (lacc)
                                     (or (< (pqueue-length acc) max-schema)
                                         (< (pqueue-front-key acc) f))))
                          (let ((children (expand node)))
                            (bt:with-lock-held (lopen)
                              (iter (for child in children)
                                    (pqueue-push child f open)))))))))
                (worker ()
                  (sleep (random 1.0))
                  (block nil
                    (tagbody
                      :start
                      (task
                       (bt:with-lock-held (lacc)
                         (bt:with-lock-held (lopen)
                           (if (or (< (pqueue-length acc) max-schema)
                                   (< (pqueue-front-key acc)
                                      (pqueue-front-key open)))
                               (if (pqueue-empty-p open)
                                   (go :retry)
                                   (pqueue-pop open))
                               (go :end)))))
                      (go :start)
                      :retry
                      (sleep 0.1)
                      (go :start)
                      :end))))
         (let ((init (node (multitoken (* 2 width))
                           (multitoken (* 2 width)))))
           (pqueue-push init
                        (multiple-value-call
                            #'cross-entropy
                          (contingency-table init array))
                        open))
         (dotimes (i *num-processes*)
           (push (bt:make-thread #'worker) threads))
         (unwind-protect
          (handler-case
              (map nil #'bt:join-thread threads)
            (SB-SYS:INTERACTIVE-INTERRUPT ()
              (map nil #'bt:destroy-thread threads)))
           (print-variables acc)))
       (iter (until (pqueue-empty-p acc))
             (for (values node g) = (pqueue-pop acc))
             (print-variables g node)
             (collect node))))))

(defvar *g-threshold* most-negative-short-float)
(defvar *max-schema* most-positive-fixnum)
(defvar *num-samples* nil)
(setf *print-right-margin* 70)
;; (setf *print-pretty* nil)
(defun main (&rest args)
  (match args
    ((list* (or "-g" "--threashold") (read *g-threshold*) rest)
     (check-type *g-threshold* real)
     (apply #'main rest))
    ((list* (or "-s" "--seed") (read seed) rest)
     (check-type seed (unsigned-byte 32))
     (let ((*random-state* (SB-EXT:SEED-RANDOM-STATE seed)))
       (apply #'main rest)))
    ((list* (or "-k" "--max-schema") (read *max-schema*) rest)
     (check-type *max-schema* integer)
     (apply #'main rest))
    ((list* (or "-n" "--num-samples") (read *num-samples*) rest)
     (check-type *num-samples* integer)
     (apply #'main rest))
    ((list* (or "-P" "--num-processes") (read *num-processes*) rest)
     (check-type *num-processes* integer)
     (apply #'main rest))
    ((list* (or "-p" "--profile") rest)
     (swank:profile-reset)
     (swank:profile-package :msdd t nil)
     (apply #'main rest)
     (swank:profile-report))
    ((list* (or "-t" "--time") rest)
     (let ((*trace-output* *error-output*))
       (time (apply #'main rest))))
    ((list csv)
     (format *error-output* "number of threads: ~a~%" *num-processes*)
     (format
      t "~&~(~:S~)~%"
      (make-domain
       (mapcar #'as-012
               (bistate-msdd
                (bvs-array
                 (if *num-samples*
                     (simpsamp:list-sample
                      *num-samples*
                      (let ((list (read-as-bvs csv)))
                        (format *error-output*
                                "number of original samples: ~a~%"
                                (length list))
                        list))
                     (read-as-bvs csv)))
                *g-threshold* *max-schema*)))))
    (_
     (format *error-output*
             "Usage: msdd.ros ~
                     [-g,--threashold threashold] ~
                     [-p,--profile] ~
                     [-t,--time] actions.csv~%"))))

;;; vim: set ft=lisp lisp:




